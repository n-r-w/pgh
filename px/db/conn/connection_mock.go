// Code generated by MockGen. DO NOT EDIT.
// Source: connection.go
//
// Generated by this command:
//
//	mockgen -source connection.go -destination connection_mock.go -package conn
//

// Package conn is a generated GoMock package.
package conn

import (
	context "context"
	reflect "reflect"

	pgx "github.com/jackc/pgx/v5"
	pgconn "github.com/jackc/pgx/v5/pgconn"
	txmgr "github.com/n-r-w/pgh/v2/txmgr"
	gomock "go.uber.org/mock/gomock"
)

// MockIConnection is a mock of IConnection interface.
type MockIConnection struct {
	ctrl     *gomock.Controller
	recorder *MockIConnectionMockRecorder
}

// MockIConnectionMockRecorder is the mock recorder for MockIConnection.
type MockIConnectionMockRecorder struct {
	mock *MockIConnection
}

// NewMockIConnection creates a new mock instance.
func NewMockIConnection(ctrl *gomock.Controller) *MockIConnection {
	mock := &MockIConnection{ctrl: ctrl}
	mock.recorder = &MockIConnectionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIConnection) EXPECT() *MockIConnectionMockRecorder {
	return m.recorder
}

// CopyFrom mocks base method.
func (m *MockIConnection) CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyFrom", ctx, tableName, columnNames, rowSrc)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CopyFrom indicates an expected call of CopyFrom.
func (mr *MockIConnectionMockRecorder) CopyFrom(ctx, tableName, columnNames, rowSrc any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyFrom", reflect.TypeOf((*MockIConnection)(nil).CopyFrom), ctx, tableName, columnNames, rowSrc)
}

// Exec mocks base method.
func (m *MockIConnection) Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sql}
	for _, a := range arguments {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(pgconn.CommandTag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockIConnectionMockRecorder) Exec(ctx, sql any, arguments ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sql}, arguments...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIConnection)(nil).Exec), varargs...)
}

// InTransaction mocks base method.
func (m *MockIConnection) InTransaction() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InTransaction")
	ret0, _ := ret[0].(bool)
	return ret0
}

// InTransaction indicates an expected call of InTransaction.
func (mr *MockIConnectionMockRecorder) InTransaction() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InTransaction", reflect.TypeOf((*MockIConnection)(nil).InTransaction))
}

// LargeObjects mocks base method.
func (m *MockIConnection) LargeObjects() pgx.LargeObjects {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LargeObjects")
	ret0, _ := ret[0].(pgx.LargeObjects)
	return ret0
}

// LargeObjects indicates an expected call of LargeObjects.
func (mr *MockIConnectionMockRecorder) LargeObjects() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LargeObjects", reflect.TypeOf((*MockIConnection)(nil).LargeObjects))
}

// Query mocks base method.
func (m *MockIConnection) Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sql}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(pgx.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockIConnectionMockRecorder) Query(ctx, sql any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sql}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockIConnection)(nil).Query), varargs...)
}

// QueryRow mocks base method.
func (m *MockIConnection) QueryRow(ctx context.Context, sql string, args ...any) pgx.Row {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sql}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(pgx.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockIConnectionMockRecorder) QueryRow(ctx, sql any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sql}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockIConnection)(nil).QueryRow), varargs...)
}

// SendBatch mocks base method.
func (m *MockIConnection) SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendBatch", ctx, b)
	ret0, _ := ret[0].(pgx.BatchResults)
	return ret0
}

// SendBatch indicates an expected call of SendBatch.
func (mr *MockIConnectionMockRecorder) SendBatch(ctx, b any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendBatch", reflect.TypeOf((*MockIConnection)(nil).SendBatch), ctx, b)
}

// TransactionOptions mocks base method.
func (m *MockIConnection) TransactionOptions() txmgr.Options {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TransactionOptions")
	ret0, _ := ret[0].(txmgr.Options)
	return ret0
}

// TransactionOptions indicates an expected call of TransactionOptions.
func (mr *MockIConnectionMockRecorder) TransactionOptions() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransactionOptions", reflect.TypeOf((*MockIConnection)(nil).TransactionOptions))
}

// WithoutTransaction mocks base method.
func (m *MockIConnection) WithoutTransaction(ctx context.Context) context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithoutTransaction", ctx)
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// WithoutTransaction indicates an expected call of WithoutTransaction.
func (mr *MockIConnectionMockRecorder) WithoutTransaction(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithoutTransaction", reflect.TypeOf((*MockIConnection)(nil).WithoutTransaction), ctx)
}

// MockIStartStopConnector is a mock of IStartStopConnector interface.
type MockIStartStopConnector struct {
	ctrl     *gomock.Controller
	recorder *MockIStartStopConnectorMockRecorder
}

// MockIStartStopConnectorMockRecorder is the mock recorder for MockIStartStopConnector.
type MockIStartStopConnectorMockRecorder struct {
	mock *MockIStartStopConnector
}

// NewMockIStartStopConnector creates a new mock instance.
func NewMockIStartStopConnector(ctrl *gomock.Controller) *MockIStartStopConnector {
	mock := &MockIStartStopConnector{ctrl: ctrl}
	mock.recorder = &MockIStartStopConnectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStartStopConnector) EXPECT() *MockIStartStopConnectorMockRecorder {
	return m.recorder
}

// Connection mocks base method.
func (m *MockIStartStopConnector) Connection(ctx context.Context, opt ...ConnectionOption) IConnection {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opt {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Connection", varargs...)
	ret0, _ := ret[0].(IConnection)
	return ret0
}

// Connection indicates an expected call of Connection.
func (mr *MockIStartStopConnectorMockRecorder) Connection(ctx any, opt ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opt...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connection", reflect.TypeOf((*MockIStartStopConnector)(nil).Connection), varargs...)
}

// Start mocks base method.
func (m *MockIStartStopConnector) Start(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockIStartStopConnectorMockRecorder) Start(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockIStartStopConnector)(nil).Start), ctx)
}

// Stop mocks base method.
func (m *MockIStartStopConnector) Stop(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockIStartStopConnectorMockRecorder) Stop(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockIStartStopConnector)(nil).Stop), ctx)
}
